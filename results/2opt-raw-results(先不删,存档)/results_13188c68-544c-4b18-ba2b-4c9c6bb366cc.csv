dataset,sample_id,response,is_success,total_distance,run_time,routes,timestamp
X-n110-k13,0,"```python
@funsearch.evolve
def construction_heuristic(ctx: ConstructionContext) -> float:
    # Enhanced heuristic considering both distance and demand utilization
    distance_weight = 1.0
    utilization_weight = 0.5  # Balances distance and capacity utilization
    
    # Normalized distance (0-1 range)
    normalized_dist = ctx.distance / np.max(ctx.locations)
    
    # Capacity utilization ratio (0-1 range)
    utilization = (ctx.vehicle_load + ctx.demand) / ctx.vehicle_capacity
    
    return (distance_weight * normalized_dist + 
            utilization_weight * utilization)
```",True,19148.813034247974,1.885134220123291,"[[0, 49, 14, 3, 108, 91, 6, 18, 109, 0], [0, 19, 58, 12, 41, 68, 54, 28, 31, 39, 0], [0, 52, 50, 27, 17, 95, 59, 65, 36, 93, 0], [0, 38, 5, 46, 77, 84, 24, 103, 25, 56, 30, 0], [0, 71, 80, 2, 43, 104, 60, 61, 64, 99, 0], [0, 69, 4, 101, 33, 9, 102, 55, 76, 22, 0], [0, 62, 100, 40, 47, 86, 10, 63, 72, 21, 0], [0, 1, 79, 32, 105, 45, 34, 67, 85, 89, 0], [0, 8, 48, 57, 13, 23, 70, 44, 98, 0], [0, 90, 16, 78, 29, 81, 94, 37, 107, 0], [0, 51, 11, 87, 26, 53, 15, 66, 42, 0], [0, 96, 88, 75, 73, 35, 7, 82, 74, 0], [0, 20, 92, 97, 106, 83, 0]]",2025-04-10 19:57:02
X-n110-k13,1,"Here's the improved `construction_heuristic` function:

```python
@funsearch.evolve
def construction_heuristic(ctx: ConstructionContext) -> float:
    # Enhanced heuristic combining distance and capacity utilization
    distance_score = ctx.distance / np.max(ctx.locations)  # Normalized distance
    capacity_score = (ctx.vehicle_load + ctx.demand) / ctx.vehicle_capacity  # Utilization ratio
    
    # Weighted combination favoring closer nodes and better capacity utilization
    return 0.7 * distance_score + 0.3 * capacity_score
```

This implementation:
1. Normalizes the distance by dividing by maximum possible distance (using locations)
2. Calculates capacity utilization ratio
3. Uses weighted combination (70% distance, 30% capacity) to balance both factors
4. Returns a single score that can be used to compare candidate nodes

The weights (0.7 and 0.3) can be adjusted based on problem characteristics, but this ratio generally provides a good balance between minimizing distance and maximizing vehicle utilization.",True,18772.542258809903,1.7898101806640625,"[[0, 49, 14, 3, 108, 91, 6, 18, 109, 0], [0, 19, 58, 12, 41, 68, 54, 28, 31, 39, 0], [0, 52, 50, 27, 17, 95, 59, 65, 36, 93, 0], [0, 38, 5, 46, 77, 84, 24, 103, 25, 56, 30, 0], [0, 71, 80, 2, 43, 104, 60, 61, 64, 99, 0], [0, 69, 4, 101, 33, 9, 102, 55, 76, 22, 0], [0, 62, 100, 40, 47, 86, 10, 63, 72, 21, 0], [0, 8, 48, 57, 13, 23, 70, 44, 32, 0], [0, 1, 79, 105, 45, 34, 67, 98, 85, 89, 0], [0, 90, 16, 78, 29, 81, 94, 37, 107, 0], [0, 51, 11, 87, 26, 53, 15, 66, 42, 0], [0, 96, 88, 75, 73, 35, 7, 82, 74, 0], [0, 20, 92, 97, 106, 83, 0]]",2025-04-10 19:57:04
X-n110-k13,2,"```python
@funsearch.evolve
def construction_heuristic(ctx: ConstructionContext) -> float:
    # Combined heuristic with adjusted weights for distance and capacity
    distance_score = ctx.distance
    capacity_score = (ctx.vehicle_load + ctx.demand) / ctx.vehicle_capacity
    
    # Dynamic weighting based on current vehicle load
    distance_weight = 0.8 if ctx.vehicle_load < ctx.vehicle_capacity * 0.7 else 0.5
    capacity_weight = 1 - distance_weight
    
    return distance_weight * distance_score + capacity_weight * capacity_score * 1000
```",True,18832.768031567943,1.8066740036010742,"[[0, 49, 14, 3, 108, 91, 6, 18, 109, 0], [0, 19, 58, 12, 41, 68, 54, 17, 27, 31, 39, 0], [0, 52, 50, 28, 95, 59, 65, 36, 93, 0], [0, 38, 32, 105, 45, 34, 67, 89, 46, 5, 0], [0, 71, 80, 60, 102, 101, 4, 84, 24, 103, 25, 56, 30, 0], [0, 69, 77, 26, 53, 15, 98, 11, 85, 51, 0], [0, 8, 40, 47, 86, 10, 72, 63, 100, 62, 0], [0, 1, 79, 90, 16, 70, 44, 107, 23, 0], [0, 2, 43, 83, 22, 61, 104, 64, 99, 0], [0, 48, 13, 57, 82, 7, 37, 94, 78, 0], [0, 96, 88, 75, 21, 73, 35, 81, 74, 0], [0, 55, 76, 33, 9, 87, 106, 97, 20, 0], [0, 66, 42, 92, 29, 0]]",2025-04-10 19:57:05
X-n115-k10,0,"Here's the improved `construction_heuristic` function that considers both distance and vehicle load utilization:

```python
@funsearch.evolve
def construction_heuristic(ctx: ConstructionContext) -> float:
    # Combines distance and vehicle load utilization with adaptive weights
    distance_weight = 1.0
    utilization_weight = 0.5  # Favors nodes that better utilize remaining capacity
    normalized_distance = ctx.distance / np.max(ctx.locations)
    utilization = (ctx.vehicle_load + ctx.demand) / ctx.vehicle_capacity
    
    return (distance_weight * normalized_distance - 
            utilization_weight * utilization)
```

This implementation:
1. Normalizes distance to make it comparable across different problem scales
2. Considers both distance and vehicle utilization
3. Uses negative weight for utilization since we want to maximize it
4. Maintains the same interface while providing better routing decisions",True,16753.36907428885,1.845179796218872,"[[0, 10, 42, 59, 95, 107, 92, 57, 100, 28, 78, 53, 29, 52, 0], [0, 2, 91, 41, 104, 16, 66, 17, 89, 32, 15, 50, 21, 110, 0], [0, 36, 11, 31, 56, 70, 69, 102, 24, 98, 39, 90, 74, 63, 34, 72, 26, 0], [0, 46, 64, 7, 1, 71, 76, 61, 0], [0, 13, 111, 9, 54, 101, 4, 0], [0, 35, 99, 49, 109, 18, 93, 3, 47, 79, 87, 73, 48, 108, 106, 0], [0, 82, 88, 85, 112, 105, 27, 44, 30, 114, 75, 84, 83, 8, 14, 68, 43, 67, 40, 37, 55, 81, 0], [0, 5, 19, 6, 60, 86, 0], [0, 25, 51, 22, 96, 23, 65, 45, 12, 113, 58, 77, 38, 80, 97, 33, 103, 62, 0], [0, 20, 94, 0]]",2025-04-10 19:57:45
X-n115-k10,1,"Here's the improved `construction_heuristic` function that better balances distance and capacity utilization:

```python
@funsearch.evolve
def construction_heuristic(ctx: ConstructionContext) -> float:
    # Weighted combination of distance and capacity utilization
    distance_factor = ctx.distance / np.max(ctx.locations)
    capacity_factor = (ctx.vehicle_capacity - (ctx.vehicle_load + ctx.demand)) / ctx.vehicle_capacity
    
    # Dynamic weighting based on current vehicle load
    if ctx.vehicle_load < 0.5 * ctx.vehicle_capacity:
        return 0.7 * distance_factor + 0.3 * capacity_factor
    else:
        return 0.3 * distance_factor + 0.7 * capacity_factor
```

This version:
1. Normalizes both distance and capacity factors
2. Uses dynamic weighting based on current vehicle load
3. Prioritizes distance when vehicle is empty, capacity when nearly full
4. Maintains the same interface while providing better routing decisions",True,17668.94785377139,1.8154680728912354,"[[0, 10, 9, 88, 0], [0, 15, 2, 69, 7, 63, 34, 0], [0, 50, 52, 21, 82, 29, 53, 78, 57, 4, 92, 107, 95, 59, 42, 0], [0, 46, 64, 1, 8, 83, 0], [0, 13, 70, 36, 56, 31, 103, 61, 33, 11, 81, 113, 45, 96, 19, 0], [0, 32, 66, 106, 47, 79, 49, 99, 35, 18, 109, 93, 3, 0], [0, 111, 110, 112, 105, 27, 44, 30, 114, 94, 20, 101, 62, 54, 100, 28, 48, 108, 5, 0], [0, 26, 72, 102, 24, 65, 12, 37, 98, 74, 90, 39, 67, 43, 68, 14, 40, 75, 84, 85, 0], [0, 89, 17, 16, 104, 41, 91, 25, 73, 87, 86, 60, 6, 51, 22, 23, 38, 97, 55, 0], [0, 71, 76, 80, 77, 58, 0]]",2025-04-10 19:57:47
X-n115-k10,2,"```python
@funsearch.evolve
def construction_heuristic(ctx: ConstructionContext) -> float:
    # Enhanced heuristic combining distance, capacity utilization and proximity to depot
    distance_to_node = ctx.distance
    distance_to_depot = np.linalg.norm(ctx.locations[ctx.candidate] - ctx.locations[ctx.depot])
    capacity_utilization = (ctx.vehicle_load + ctx.demand) / ctx.vehicle_capacity
    
    # Weighted combination with adjusted coefficients
    return (0.5 * distance_to_node + 
            0.3 * distance_to_depot + 
            0.2 * (1 - capacity_utilization))
```",False,N/A,1.7783379554748535,[],2025-04-10 19:57:49
