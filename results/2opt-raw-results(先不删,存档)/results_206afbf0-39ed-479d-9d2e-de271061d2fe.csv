dataset,sample_id,response,is_success,total_distance,run_time,routes,timestamp
X-n110-k13,0,"```python
@funsearch.evolve
def construction_heuristic(ctx: ConstructionContext) -> float:
    # Enhanced heuristic considering both distance and demand utilization
    distance_weight = 1.0
    utilization_weight = 0.5  # Balances distance and capacity utilization
    
    # Normalized distance (0-1 range)
    normalized_dist = ctx.distance / np.max(ctx.locations)
    
    # Capacity utilization ratio (0-1 range)
    utilization = (ctx.vehicle_load + ctx.demand) / ctx.vehicle_capacity
    
    return (distance_weight * normalized_dist + 
            utilization_weight * utilization)
```",True,19148.813034247974,1.885134220123291,"[[0, 49, 14, 3, 108, 91, 6, 18, 109, 0], [0, 19, 58, 12, 41, 68, 54, 28, 31, 39, 0], [0, 52, 50, 27, 17, 95, 59, 65, 36, 93, 0], [0, 38, 5, 46, 77, 84, 24, 103, 25, 56, 30, 0], [0, 71, 80, 2, 43, 104, 60, 61, 64, 99, 0], [0, 69, 4, 101, 33, 9, 102, 55, 76, 22, 0], [0, 62, 100, 40, 47, 86, 10, 63, 72, 21, 0], [0, 1, 79, 32, 105, 45, 34, 67, 85, 89, 0], [0, 8, 48, 57, 13, 23, 70, 44, 98, 0], [0, 90, 16, 78, 29, 81, 94, 37, 107, 0], [0, 51, 11, 87, 26, 53, 15, 66, 42, 0], [0, 96, 88, 75, 73, 35, 7, 82, 74, 0], [0, 20, 92, 97, 106, 83, 0]]",2025-04-10 19:57:02
X-n110-k13,1,"Here's the improved `construction_heuristic` function:

```python
@funsearch.evolve
def construction_heuristic(ctx: ConstructionContext) -> float:
    # Enhanced heuristic combining distance and capacity utilization
    distance_score = ctx.distance / np.max(ctx.locations)  # Normalized distance
    capacity_score = (ctx.vehicle_load + ctx.demand) / ctx.vehicle_capacity  # Utilization ratio
    
    # Weighted combination favoring closer nodes and better capacity utilization
    return 0.7 * distance_score + 0.3 * capacity_score
```

This implementation:
1. Normalizes the distance by dividing by maximum possible distance (using locations)
2. Calculates capacity utilization ratio
3. Uses weighted combination (70% distance, 30% capacity) to balance both factors
4. Returns a single score that can be used to compare candidate nodes

The weights (0.7 and 0.3) can be adjusted based on problem characteristics, but this ratio generally provides a good balance between minimizing distance and maximizing vehicle utilization.",True,18772.542258809903,1.7898101806640625,"[[0, 49, 14, 3, 108, 91, 6, 18, 109, 0], [0, 19, 58, 12, 41, 68, 54, 28, 31, 39, 0], [0, 52, 50, 27, 17, 95, 59, 65, 36, 93, 0], [0, 38, 5, 46, 77, 84, 24, 103, 25, 56, 30, 0], [0, 71, 80, 2, 43, 104, 60, 61, 64, 99, 0], [0, 69, 4, 101, 33, 9, 102, 55, 76, 22, 0], [0, 62, 100, 40, 47, 86, 10, 63, 72, 21, 0], [0, 8, 48, 57, 13, 23, 70, 44, 32, 0], [0, 1, 79, 105, 45, 34, 67, 98, 85, 89, 0], [0, 90, 16, 78, 29, 81, 94, 37, 107, 0], [0, 51, 11, 87, 26, 53, 15, 66, 42, 0], [0, 96, 88, 75, 73, 35, 7, 82, 74, 0], [0, 20, 92, 97, 106, 83, 0]]",2025-04-10 19:57:04
X-n110-k13,2,"```python
@funsearch.evolve
def construction_heuristic(ctx: ConstructionContext) -> float:
    # Combined heuristic with adjusted weights for distance and capacity
    distance_score = ctx.distance
    capacity_score = (ctx.vehicle_load + ctx.demand) / ctx.vehicle_capacity
    
    # Dynamic weighting based on current vehicle load
    distance_weight = 0.8 if ctx.vehicle_load < ctx.vehicle_capacity * 0.7 else 0.5
    capacity_weight = 1 - distance_weight
    
    return distance_weight * distance_score + capacity_weight * capacity_score * 1000
```",True,18832.768031567943,1.8066740036010742,"[[0, 49, 14, 3, 108, 91, 6, 18, 109, 0], [0, 19, 58, 12, 41, 68, 54, 17, 27, 31, 39, 0], [0, 52, 50, 28, 95, 59, 65, 36, 93, 0], [0, 38, 32, 105, 45, 34, 67, 89, 46, 5, 0], [0, 71, 80, 60, 102, 101, 4, 84, 24, 103, 25, 56, 30, 0], [0, 69, 77, 26, 53, 15, 98, 11, 85, 51, 0], [0, 8, 40, 47, 86, 10, 72, 63, 100, 62, 0], [0, 1, 79, 90, 16, 70, 44, 107, 23, 0], [0, 2, 43, 83, 22, 61, 104, 64, 99, 0], [0, 48, 13, 57, 82, 7, 37, 94, 78, 0], [0, 96, 88, 75, 21, 73, 35, 81, 74, 0], [0, 55, 76, 33, 9, 87, 106, 97, 20, 0], [0, 66, 42, 92, 29, 0]]",2025-04-10 19:57:05
X-n115-k10,0,"Here's the improved `construction_heuristic` function that considers both distance and vehicle load utilization:

```python
@funsearch.evolve
def construction_heuristic(ctx: ConstructionContext) -> float:
    # Combines distance and vehicle load utilization with adaptive weights
    distance_weight = 1.0
    utilization_weight = 0.5  # Favors nodes that better utilize remaining capacity
    normalized_distance = ctx.distance / np.max(ctx.locations)
    utilization = (ctx.vehicle_load + ctx.demand) / ctx.vehicle_capacity
    
    return (distance_weight * normalized_distance - 
            utilization_weight * utilization)
```

This implementation:
1. Normalizes distance to make it comparable across different problem scales
2. Considers both distance and vehicle utilization
3. Uses negative weight for utilization since we want to maximize it
4. Maintains the same interface while providing better routing decisions",True,16753.36907428885,1.845179796218872,"[[0, 10, 42, 59, 95, 107, 92, 57, 100, 28, 78, 53, 29, 52, 0], [0, 2, 91, 41, 104, 16, 66, 17, 89, 32, 15, 50, 21, 110, 0], [0, 36, 11, 31, 56, 70, 69, 102, 24, 98, 39, 90, 74, 63, 34, 72, 26, 0], [0, 46, 64, 7, 1, 71, 76, 61, 0], [0, 13, 111, 9, 54, 101, 4, 0], [0, 35, 99, 49, 109, 18, 93, 3, 47, 79, 87, 73, 48, 108, 106, 0], [0, 82, 88, 85, 112, 105, 27, 44, 30, 114, 75, 84, 83, 8, 14, 68, 43, 67, 40, 37, 55, 81, 0], [0, 5, 19, 6, 60, 86, 0], [0, 25, 51, 22, 96, 23, 65, 45, 12, 113, 58, 77, 38, 80, 97, 33, 103, 62, 0], [0, 20, 94, 0]]",2025-04-10 19:57:45
X-n115-k10,1,"Here's the improved `construction_heuristic` function that better balances distance and capacity utilization:

```python
@funsearch.evolve
def construction_heuristic(ctx: ConstructionContext) -> float:
    # Weighted combination of distance and capacity utilization
    distance_factor = ctx.distance / np.max(ctx.locations)
    capacity_factor = (ctx.vehicle_capacity - (ctx.vehicle_load + ctx.demand)) / ctx.vehicle_capacity
    
    # Dynamic weighting based on current vehicle load
    if ctx.vehicle_load < 0.5 * ctx.vehicle_capacity:
        return 0.7 * distance_factor + 0.3 * capacity_factor
    else:
        return 0.3 * distance_factor + 0.7 * capacity_factor
```

This version:
1. Normalizes both distance and capacity factors
2. Uses dynamic weighting based on current vehicle load
3. Prioritizes distance when vehicle is empty, capacity when nearly full
4. Maintains the same interface while providing better routing decisions",True,17668.94785377139,1.8154680728912354,"[[0, 10, 9, 88, 0], [0, 15, 2, 69, 7, 63, 34, 0], [0, 50, 52, 21, 82, 29, 53, 78, 57, 4, 92, 107, 95, 59, 42, 0], [0, 46, 64, 1, 8, 83, 0], [0, 13, 70, 36, 56, 31, 103, 61, 33, 11, 81, 113, 45, 96, 19, 0], [0, 32, 66, 106, 47, 79, 49, 99, 35, 18, 109, 93, 3, 0], [0, 111, 110, 112, 105, 27, 44, 30, 114, 94, 20, 101, 62, 54, 100, 28, 48, 108, 5, 0], [0, 26, 72, 102, 24, 65, 12, 37, 98, 74, 90, 39, 67, 43, 68, 14, 40, 75, 84, 85, 0], [0, 89, 17, 16, 104, 41, 91, 25, 73, 87, 86, 60, 6, 51, 22, 23, 38, 97, 55, 0], [0, 71, 76, 80, 77, 58, 0]]",2025-04-10 19:57:47
X-n115-k10,2,"```python
@funsearch.evolve
def construction_heuristic(ctx: ConstructionContext) -> float:
    # Enhanced heuristic combining distance, capacity utilization and proximity to depot
    distance_to_node = ctx.distance
    distance_to_depot = np.linalg.norm(ctx.locations[ctx.candidate] - ctx.locations[ctx.depot])
    capacity_utilization = (ctx.vehicle_load + ctx.demand) / ctx.vehicle_capacity
    
    # Weighted combination with adjusted coefficients
    return (0.5 * distance_to_node + 
            0.3 * distance_to_depot + 
            0.2 * (1 - capacity_utilization))
```",False,N/A,1.7783379554748535,[],2025-04-10 19:57:49
X-n120-k6,0,"Here's the improved `construction_heuristic` function that considers both distance and vehicle load utilization:

```python
@funsearch.evolve
def construction_heuristic(ctx: ConstructionContext) -> float:
    # Weighted combination of distance and remaining capacity utilization
    distance_weight = 1.0
    capacity_weight = 0.5  # Adjust based on importance of capacity utilization
    
    # Normalize distance and capacity factors
    normalized_distance = ctx.distance / np.max(ctx.locations)
    capacity_utilization = (ctx.vehicle_load + ctx.demand) / ctx.vehicle_capacity
    
    return distance_weight * normalized_distance - capacity_weight * capacity_utilization
```

This implementation:
1. Uses both distance and capacity utilization in the heuristic
2. Normalizes the distance component by dividing by maximum possible distance
3. Uses weights to balance the importance of distance vs capacity utilization
4. Subtracts capacity utilization since we want to favor routes with better capacity usage
5. Maintains the same function signature and return type",True,15175.667205048494,1.8153491020202637,"[[0, 20, 116, 107, 61, 119, 84, 55, 70, 93, 16, 80, 29, 25, 73, 31, 38, 52, 94, 10, 88, 50, 0], [0, 96, 71, 54, 112, 45, 3, 78, 39, 42, 109, 82, 98, 13, 99, 9, 113, 64, 76, 43, 2, 49, 0], [0, 32, 91, 21, 12, 41, 5, 26, 103, 17, 18, 44, 15, 83, 58, 14, 23, 33, 79, 118, 30, 67, 0], [0, 62, 40, 57, 77, 100, 60, 95, 4, 22, 59, 37, 24, 1, 56, 11, 27, 34, 111, 102, 72, 87, 0], [0, 8, 114, 90, 6, 92, 35, 53, 81, 69, 68, 85, 89, 51, 63, 104, 105, 101, 47, 117, 108, 66, 0], [0, 36, 115, 48, 86, 65, 74, 110, 106, 7, 97, 46, 75, 19, 28, 0]]",2025-04-10 19:58:29
X-n120-k6,1,"Here's the improved `construction_heuristic` function that considers both distance and vehicle load utilization:

```python
@funsearch.evolve
def construction_heuristic(ctx: ConstructionContext) -> float:
    # Weighted combination of distance and remaining capacity utilization
    distance_weight = 1.0
    capacity_weight = 0.5  # Adjust based on importance of capacity utilization
    
    # Normalize distance and capacity factors
    normalized_distance = ctx.distance / np.max(ctx.locations)
    capacity_utilization = (ctx.vehicle_load + ctx.demand) / ctx.vehicle_capacity
    
    return distance_weight * normalized_distance - capacity_weight * capacity_utilization
```",True,15175.667205048494,1.7951810359954834,"[[0, 20, 116, 107, 61, 119, 84, 55, 70, 93, 16, 80, 29, 25, 73, 31, 38, 52, 94, 10, 88, 50, 0], [0, 96, 71, 54, 112, 45, 3, 78, 39, 42, 109, 82, 98, 13, 99, 9, 113, 64, 76, 43, 2, 49, 0], [0, 32, 91, 21, 12, 41, 5, 26, 103, 17, 18, 44, 15, 83, 58, 14, 23, 33, 79, 118, 30, 67, 0], [0, 62, 40, 57, 77, 100, 60, 95, 4, 22, 59, 37, 24, 1, 56, 11, 27, 34, 111, 102, 72, 87, 0], [0, 8, 114, 90, 6, 92, 35, 53, 81, 69, 68, 85, 89, 51, 63, 104, 105, 101, 47, 117, 108, 66, 0], [0, 36, 115, 48, 86, 65, 74, 110, 106, 7, 97, 46, 75, 19, 28, 0]]",2025-04-10 19:58:30
X-n120-k6,2,"```python
@funsearch.evolve
def construction_heuristic(ctx: ConstructionContext) -> float:
    # Enhanced heuristic combining distance, capacity utilization and proximity to depot
    distance_weight = 1.0
    capacity_weight = 0.7
    depot_weight = 0.3
    
    # Calculate components
    normalized_distance = ctx.distance / np.max(ctx.locations)
    capacity_utilization = (ctx.vehicle_load + ctx.demand) / ctx.vehicle_capacity
    depot_proximity = np.linalg.norm(ctx.locations[ctx.candidate] - ctx.locations[ctx.depot])
    
    return (distance_weight * normalized_distance 
            - capacity_weight * capacity_utilization 
            + depot_weight * depot_proximity)
```",False,N/A,1.8011581897735596,[],2025-04-10 19:58:32
X-n139-k10,0,"Here's the improved `construction_heuristic` function that considers both distance and demand utilization:

```python
@funsearch.evolve
def construction_heuristic(ctx: ConstructionContext) -> float:
    # Weighted combination of distance and remaining capacity utilization
    distance_weight = 1.0
    capacity_weight = 0.5
    remaining_capacity = ctx.vehicle_capacity - ctx.vehicle_load
    capacity_utilization = ctx.demand / remaining_capacity if remaining_capacity > 0 else float('inf')
    return distance_weight * ctx.distance + capacity_weight * capacity_utilization
```",True,16635.267731216714,2.7461700439453125,"[[0, 98, 3, 56, 91, 89, 71, 81, 104, 63, 28, 103, 138, 122, 73, 0], [0, 7, 30, 84, 29, 87, 52, 126, 95, 118, 32, 16, 124, 88, 109, 0], [0, 54, 120, 35, 58, 13, 97, 31, 50, 110, 45, 20, 121, 79, 0], [0, 76, 111, 105, 82, 106, 77, 43, 46, 55, 21, 18, 1, 83, 0], [0, 70, 10, 74, 123, 27, 115, 34, 131, 38, 69, 94, 108, 22, 26, 9, 0], [0, 51, 39, 15, 19, 6, 5, 96, 113, 90, 12, 117, 72, 44, 8, 57, 0], [0, 85, 24, 114, 137, 125, 25, 112, 23, 4, 62, 80, 41, 92, 107, 0], [0, 78, 132, 93, 130, 127, 64, 133, 75, 86, 33, 135, 14, 40, 102, 100, 0], [0, 67, 42, 60, 59, 134, 37, 17, 11, 101, 128, 116, 68, 136, 0], [0, 99, 2, 36, 129, 53, 49, 66, 61, 48, 65, 47, 119, 0]]",2025-04-10 19:59:09
X-n139-k10,1,"Here's the improved `construction_heuristic` function that balances distance and capacity utilization:

```python
@funsearch.evolve
def construction_heuristic(ctx: ConstructionContext) -> float:
    # Enhanced heuristic considering both distance and capacity utilization
    normalized_distance = ctx.distance / np.max(ctx.locations)
    capacity_ratio = (ctx.vehicle_load + ctx.demand) / ctx.vehicle_capacity
    return 0.7 * normalized_distance + 0.3 * capacity_ratio
```

This version:
1. Normalizes the distance by dividing by maximum possible distance (using locations)
2. Considers both current load and candidate demand in capacity ratio
3. Uses weighted sum (70% distance, 30% capacity) for balanced decision making
4. Returns a single float value for comparison

The weights (0.7 and 0.3) can be further optimized through the evolutionary process.",True,17267.969581946396,2.033975124359131,"[[0, 98, 56, 91, 89, 81, 86, 136, 83, 68, 33, 135, 102, 71, 3, 0], [0, 7, 30, 84, 29, 87, 52, 126, 125, 25, 137, 114, 24, 85, 118, 95, 0], [0, 54, 79, 121, 20, 73, 45, 10, 50, 115, 123, 74, 70, 88, 109, 0], [0, 16, 32, 9, 26, 108, 94, 69, 38, 131, 23, 4, 62, 124, 0], [0, 76, 122, 138, 106, 77, 43, 46, 55, 18, 21, 103, 28, 63, 104, 0], [0, 110, 35, 58, 13, 97, 31, 80, 41, 92, 107, 64, 133, 78, 120, 0], [0, 57, 8, 15, 44, 72, 66, 19, 61, 6, 5, 96, 113, 90, 12, 117, 0], [0, 51, 39, 60, 42, 67, 100, 134, 40, 37, 17, 11, 128, 101, 0], [0, 75, 132, 93, 130, 127, 82, 105, 111, 1, 116, 14, 59, 48, 0], [0, 27, 34, 22, 112, 36, 129, 53, 49, 2, 99, 65, 47, 119, 0]]",2025-04-10 19:59:11
X-n139-k10,2,"Here's the improved `construction_heuristic` function:

```python
@funsearch.evolve
def construction_heuristic(ctx: ConstructionContext) -> float:
    # Enhanced heuristic combining distance and capacity utilization
    distance_score = ctx.distance / np.max(ctx.locations)
    capacity_score = (ctx.vehicle_load + ctx.demand) / ctx.vehicle_capacity
    return 0.6 * distance_score + 0.4 * capacity_score
```

This version:
1. Normalizes the distance by dividing by maximum possible distance (using locations)
2. Calculates capacity utilization including the candidate's demand
3. Uses weighted sum (60% distance, 40% capacity) for balanced decision making
4. Returns a single float value for comparison

The weights can be further optimized through the evolutionary process.",True,16491.95139349339,2.0946109294891357,"[[0, 98, 56, 91, 89, 81, 71, 102, 100, 67, 42, 59, 60, 8, 3, 0], [0, 7, 30, 84, 29, 87, 52, 126, 125, 25, 137, 114, 24, 85, 118, 95, 0], [0, 54, 79, 121, 73, 45, 10, 50, 27, 115, 123, 74, 70, 88, 109, 0], [0, 20, 110, 35, 58, 13, 97, 31, 80, 41, 92, 78, 133, 120, 0], [0, 16, 32, 9, 26, 108, 94, 69, 38, 131, 23, 4, 62, 124, 0], [0, 76, 122, 138, 28, 63, 104, 86, 17, 37, 40, 134, 14, 135, 33, 0], [0, 57, 44, 65, 48, 66, 19, 6, 5, 96, 113, 90, 12, 72, 117, 99, 0], [0, 51, 39, 15, 61, 53, 129, 49, 2, 36, 112, 22, 34, 107, 0], [0, 111, 105, 82, 106, 77, 43, 46, 55, 18, 21, 83, 68, 136, 103, 0], [0, 75, 132, 93, 130, 127, 64, 1, 119, 47, 11, 101, 128, 116, 0]]",2025-04-10 19:59:13
