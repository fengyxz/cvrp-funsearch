# CVRP-Funsearch

Our project focuses on the Capacitated Vehicle Routing Problem (CVRP), a popular NP-hard problem. This project introduces the innovative FunSearch method to address CVRP, leveraging Large Language Models (LLM) and Retrieval-Augmented Generation (RAG) technology for external knowledge retrieval.

The approach combines deep reasoning through chain of thought to automate program generation and search within the function space. RAG ensures precise knowledge retrieval, providing a theoretical foundation and reasoning framework, while the chain of thought decomposes CVRP into interconnected subproblems for stepwise optimization, tackling single-objective challenges effectively.

**Our goal is simply to minimize the path length, and the following constraints must be satisfied at the same time:**
- All customers are served and each customer is visited only once.
- The capacity of each vehicle is not overloaded.
- No vehicle takes the same path twice.

## Directory Explanation

cvrp-funsearch/

```
├── LLM.ipynb
├── Other_algorithms
│   ├── 0_0_Ortools_.ipynb
│   ├── 0_1_k-opt.ipynb
│   ├── 0_2_Large_Neighborhood_Search_LNS.ipynb
│   ├── 0_3_Tabu_Search.ipynb
│   ├── 0_4_Simulated_Annealing.ipynb
│   └── gif.ipynb
├── cvrp
│   ├── code_manipulation.py
│   ├── config.py
│   ├── cvrp_funsearch.py
│   ├── evaluator.py
│   ├── evaluator_accelerate.py
│   ├── programs_database.py
│   └── sampler.py
├── data
│   ├── cvrp
│   └── tsp
├── ortools
│   ├── cvrp
│   ├── cvrp-1.ipynb
│   └── cvrp.ipynb
├── others-cvrp.ipynb
├── requirements.txt
└── test_spec.txt
```

`LLM.ipynb`: This Jupyter Notebook is likely used for experiments or demonstrations related to Large Language Models (LLM), showing how LLM can generate and optimize code for solving the CVRP problem.

`Other_algorithms/`: Contains Jupyter Notebooks that implement various other algorithms for solving CVRP, used for comparison and testing the performance of different algorithms.

`cvrp/`: Contains core CVRP-related code modules.

`data/`: Contains datasets related to the problem.

`ortools/`: Contains code and Jupyter Notebooks that use Google OR-Tools to solve CVRP.

`others-cvrp.ipynb`: A Jupyter Notebook that likely consolidates or compares the implementations and results of other CVRP solving methods.

`test_spec.txt`: Likely contains specifications or descriptions of test cases used to validate the correctness of the algorithms and modules in the project.

## Design

Our architecture diagram:

<img src="https://github.com/user-attachments/assets/fa80d9ce-0738-4753-a139-bf0b01536a29" width="500px">

Simple explanation:

1. Sampler: Multiple samplers (Sampler 1-5) generate different samples.

2. Request LLM to Generate Code:

- The samplers use an API to send requests to the LLM and obtain multiple (n times) code responses.

- The generated code is based on specific Prompts, which are stored in a Database of prompt templates.

3. Evaluator for Code Evaluation:

- The code generated by the LLM is evaluated in the Evaluator.

- The code runs in a Sandbox environment, where funsearch is used for execution and optimization (run + evolve).

- The evaluation results are ranked in the Score Rank.

4. Select the Best Solution: The best-performing solution from the score ranking is selected as the Final Best Answer.

The core of this process is to generate multiple code solutions using the LLM, execute and evaluate them in a sandbox, and finally choose the optimal solution.

## Performance comparison of various algorithms

We have tried existing algorithms and also made preliminary attempts.

- 2-opt: A local search algorithm that iteratively improves a tour by swapping two edges to reduce the overall route length.

- LNS (Large Neighborhood Search): A heuristic method that destroys and rebuilds parts of a solution to explore a larger search space for better optimization.

- Tabu Search: An iterative improvement algorithm that uses memory structures to avoid cycling back to recently visited solutions, helping it escape local optima.

- SA (Simulated Annealing): A probabilistic technique that accepts occasional worse solutions to avoid local optima and gradually converges towards a global optimum.

- Ortools: Google’s open-source optimization suite that provides powerful solvers and tools for tackling various combinatorial optimization problems.

### Small Sets

table：

| Instance  | 2-opt | LNS  | TabuS | SA   | Ortools |
|-----------|------:|-----:|------:|-----:|--------:|
| A-n32-k5  |  1168 |  849 |   953 |  960 |     782 |
| A-n37-k5  |   892 |  666 |   766 |  762 |     656 |
| A-n48-k7  |  1439 | 1101 |  1225 | 1229 |    1051 |
| P-n50-k10 |   881 |  719 |   759 |  748 |     703 |

graph:

<img src="https://github.com/user-attachments/assets/d2d8af31-214a-4366-994b-ce8a331e31af" width="500px">

### Medium Sets

table:

| Instance       | 2-opt | LNS  | TabuS | SA   | Ortools |
|---------------|------:|-----:|------:|-----:|--------:|
| A-n45-k6      |  1265 |  937 |  1126 | 1047 |    1034 |
| A-n53-k7      |  1381 | 1016 |  1185 | 1191 |    1028 |
| A-n63-k10     |  1864 | 1400 |  1668 | 1564 |    1335 |
| P-n65-k10     |  1126 |  817 |   883 |  861 |     785 |
| P-n60-k10     |   956 |  811 |   797 |  810 |     759 |
| A-n80-k10     |  2155 | 1834 |  1913 | 1931 |    1831 |
| E-n76-k14     |  1344 | 1046 |  1157 | 1148 |    1045 |
| E-n101-k14.vrp |  1472 | 1131 |  1341 | 1256 |    1083 |

graph:

<img src="https://github.com/user-attachments/assets/584ce12b-938c-4700-b70c-2c5ae506512b" width="500px">

### Large Sets

table:

| Instance    | 2-opt | LNS  | TabuS | SA   | Ortools |
|------------|------:|-----:|------:|-----:|--------:|
| X-n120-k6  | 15188 | 14294 | 15794 | 15398 | 13995 |
| X-n115-k10 | 17562 | 13958 | 15792 | 14870 | 13379 |
| X-n139-k10 | 17218 | 14905 | 15931 | 15409 | 14633 |
| X-n110-k13 | 19320 | 15867 | 16845 | 16565 | 15550 |

graph:

<img src="https://github.com/user-attachments/assets/2ecacba0-78ce-42f6-a652-b953aaf024f7" width="500px">

### Sloved

table:

| Instance         | 2-opt | LNS  | TabuS | SA   | Ortools |
|-----------------|------:|-----:|------:|-----:|--------:|
| A-n45-k6.vrp    |  1265 |  937 |  1126 | 1047 |    1034 |
| P-n60-k10.vrp   |   956 |  811 |   797 |  810 |     759 |
| E-n101-k14.vrp  |  1472 | 1131 |  1341 | 1256 |    1083 |

graph:

<img src="https://github.com/user-attachments/assets/65cfed50-a869-4029-a326-90bdcc4ca18c" width="500px">

## Datasets

We choose small & medium sets as SetA.

<img src="https://github.com/user-attachments/assets/c94f8976-ff90-4f6a-b4c1-8ea1761a6172" width="500px">

We choose the large set as SetX.

<img src="https://github.com/user-attachments/assets/9915d28d-a4e2-4e26-9f7e-7702784f5996" width="500px">
