# CVRP-Funsearch

Our project focuses on the Capacitated Vehicle Routing Problem (CVRP), a popular NP-hard problem. This project introduces the innovative FunSearch method to address CVRP, leveraging Large Language Models (LLM) and Retrieval-Augmented Generation (RAG) technology for external knowledge retrieval.

The approach combines deep reasoning through chain of thought to automate program generation and search within the function space. RAG ensures precise knowledge retrieval, providing a theoretical foundation and reasoning framework, while the chain of thought decomposes CVRP into interconnected subproblems for stepwise optimization, tackling single-objective challenges effectively.

**Our goal is simply to minimize the path length, and the following constraints must be satisfied at the same time:**
- All customers are served and each customer is visited only once.
- The capacity of each vehicle is not overloaded.
- No vehicle takes the same path twice.

## Directory Explanation

cvrp-funsearch/

```
├── LLM-test
│   └── deepseek
├── Other_algorithms
│   ├── fig
│   └── ortools
└── cvrp
    ├── data
    │   ├── cvrp
    │   │   ├── large
    │   │   ├── medium
    │   │   └── small
    │   └── tsp
    ├── implementation
    ├── new_data
    └── spec
```

Some important directories:

- `LLM-test/deepseek`: Using DeepSeek API to do some tests.

- `Other_algorithms/fig/ortools`: Using ortools(Google) to do tests.

- `cvrp/`: Related to solving CVRP, like data(small, medium, large), solution, code, specification.

## Design

Our architecture diagram:

<img src="https://github.com/user-attachments/assets/fa80d9ce-0738-4753-a139-bf0b01536a29" width="500px">

Simple explanation:

1. Sampler: Multiple samplers (Sampler 1-5) generate different samples.

2. Request LLM to Generate Code:

- The samplers use an API to send requests to the LLM and obtain multiple (n times) code responses.

- The generated code is based on specific Prompts, which are stored in a Database of prompt templates.

3. Evaluator for Code Evaluation:

- The code generated by the LLM is evaluated in the Evaluator.

- The code runs in a Sandbox environment, where funsearch is used for execution and optimization (run + evolve).

- The evaluation results are ranked in the Score Rank.

4. Select the Best Solution: The best-performing solution from the score ranking is selected as the Final Best Answer.

The core of this process is to generate multiple code solutions using the LLM, execute and evaluate them in a sandbox, and finally choose the optimal solution.

## Performance comparison of various algorithms

We have tried existing algorithms and also made preliminary attempts.

- 2-opt: A local search algorithm that iteratively improves a tour by swapping two edges to reduce the overall route length.

- LNS (Large Neighborhood Search): A heuristic method that destroys and rebuilds parts of a solution to explore a larger search space for better optimization.

- Tabu Search: An iterative improvement algorithm that uses memory structures to avoid cycling back to recently visited solutions, helping it escape local optima.

- SA (Simulated Annealing): A probabilistic technique that accepts occasional worse solutions to avoid local optima and gradually converges towards a global optimum.

- Ortools: Google’s open-source optimization suite that provides powerful solvers and tools for tackling various combinatorial optimization problems.

### Small Sets

table：

| Instance  | 2-opt | LNS  | TabuS | SA   | Ortools |
|-----------|------:|-----:|------:|-----:|--------:|
| A-n32-k5  |  1168 |  849 |   953 |  960 |     782 |
| A-n37-k5  |   892 |  666 |   766 |  762 |     656 |
| A-n48-k7  |  1439 | 1101 |  1225 | 1229 |    1051 |
| P-n50-k10 |   881 |  719 |   759 |  748 |     703 |

graph:

<img src="https://github.com/user-attachments/assets/d2d8af31-214a-4366-994b-ce8a331e31af" width="500px">

### Medium Sets

table:

| Instance       | 2-opt | LNS  | TabuS | SA   | Ortools |
|---------------|------:|-----:|------:|-----:|--------:|
| A-n45-k6      |  1265 |  937 |  1126 | 1047 |    1034 |
| A-n53-k7      |  1381 | 1016 |  1185 | 1191 |    1028 |
| A-n63-k10     |  1864 | 1400 |  1668 | 1564 |    1335 |
| P-n65-k10     |  1126 |  817 |   883 |  861 |     785 |
| P-n60-k10     |   956 |  811 |   797 |  810 |     759 |
| A-n80-k10     |  2155 | 1834 |  1913 | 1931 |    1831 |
| E-n76-k14     |  1344 | 1046 |  1157 | 1148 |    1045 |
| E-n101-k14.vrp |  1472 | 1131 |  1341 | 1256 |    1083 |

graph:

<img src="https://github.com/user-attachments/assets/584ce12b-938c-4700-b70c-2c5ae506512b" width="500px">

### Large Sets

table:

| Instance    | 2-opt | LNS  | TabuS | SA   | Ortools |
|------------|------:|-----:|------:|-----:|--------:|
| X-n120-k6  | 15188 | 14294 | 15794 | 15398 | 13995 |
| X-n115-k10 | 17562 | 13958 | 15792 | 14870 | 13379 |
| X-n139-k10 | 17218 | 14905 | 15931 | 15409 | 14633 |
| X-n110-k13 | 19320 | 15867 | 16845 | 16565 | 15550 |

graph:

<img src="https://github.com/user-attachments/assets/2ecacba0-78ce-42f6-a652-b953aaf024f7" width="500px">

### Sloved

table:

| Instance         | 2-opt | LNS  | TabuS | SA   | Ortools |
|-----------------|------:|-----:|------:|-----:|--------:|
| A-n45-k6.vrp    |  1265 |  937 |  1126 | 1047 |    1034 |
| P-n60-k10.vrp   |   956 |  811 |   797 |  810 |     759 |
| E-n101-k14.vrp  |  1472 | 1131 |  1341 | 1256 |    1083 |

graph:

<img src="https://github.com/user-attachments/assets/65cfed50-a869-4029-a326-90bdcc4ca18c" width="500px">

## Datasets

We choose small & medium sets as SetA.

<img src="https://github.com/user-attachments/assets/c94f8976-ff90-4f6a-b4c1-8ea1761a6172" width="500px">

We choose the large set as SetX.

<img src="https://github.com/user-attachments/assets/9915d28d-a4e2-4e26-9f7e-7702784f5996" width="500px">
