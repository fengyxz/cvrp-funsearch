import ast
import copy
import re
import time
import sand_box


# Trim the code generated by the LLM to ensure it only contains the function body
def md_to_source_code(md_text):
    # Define a regular expression pattern to match Python code blocks
    pattern = re.compile(r'```python(.*?)```', re.DOTALL)
    match = pattern.search(md_text)
    if match:
        # Extract the code block content and remove leading and trailing whitespace
        return match.group(1).strip()
    return None

def _trim_function_body(generated_code: str) -> str:
    """
    Parse the code generated by the LLM to ensure only the function body is extracted.
    """
    code = md_to_source_code(generated_code)
    try:
        return "\n".join(code.split("\n"))  # Only keep the function body
    except():
        KeyError

def response_to_code(generated_response: str, template: str, function_to_evolve: str):
    """
    generated_response: The generated response;
    template: The template code used;
    function_to_evolve: The name of the function to be replaced;
    Combine the template code to generate a complete runnable program.
    """
    trimmed_function = _trim_function_body(generated_response)  # Trim the function body
    program = copy.deepcopy(template)  # Copy the template code
    new_code = replace_function_by_name(program, function_to_evolve, trimmed_function)  # Replace the target function
    return new_code

def replace_function_by_name(source_code, old_function_name, new_function_str):
    try:
        # Parse the source code into an AST
        tree = ast.parse(source_code)
    except Exception as e:
        print(f"Failed to parse source code: {e}")
        return source_code

    try:
        # Parse the new function string and extract the function definition node
        new_function_ast = ast.parse(new_function_str).body[0]
    except Exception as e:
        print(f"Failed to parse new function: {e}")
        return source_code

    class FunctionReplacer(ast.NodeTransformer):
        def visit_FunctionDef(self, node):
            # Replace the function if the name matches
            if node.name == old_function_name:
                return new_function_ast
            return self.generic_visit(node)

    try:
        # Transform the AST
        replacer = FunctionReplacer()
        new_tree = replacer.visit(tree)
        ast.fix_missing_locations(new_tree)

        # Convert the modified AST back to source code
        new_code = ast.unparse(new_tree)
        return new_code
    except Exception as e:
        print(f"Error during AST transformation or unparse: {e}")
        return source_code

# Code evaluator
class Evaluator:
    def __init__(self, template, function_to_evolve, function_to_run, input, timeout_seconds=300):
        """
        Evaluate the code generated by the LLM.
        :param template: The code template
        :param function_to_evolve: The function to be optimized
        :param function_to_run: The function to be run
        :param input: The test input data
        :param timeout_seconds: The timeout in seconds for code execution
        :param sandbox_class: The sandbox class (for safe code execution)
        """
        self._template = template
        self._function_to_evolve = function_to_evolve
        self._function_to_run = function_to_run
        self._input = input
        self._timeout_seconds = timeout_seconds

    def analyse(self, sample):
        """
        Evaluate the code solution generated by the LLM to check if it generates a valid path plan for the given input and record the running time.

        Parameters:
            sample (Any): The sample input used to generate the code.

        Returns:
            Tuple[
                bool,              # Whether the evaluation was successful (True for success, False for failure)
                float | str,       # The total distance if successful, an empty string if failed
                List[List[int]],   # The paths of all vehicles if successful, an empty list if failed
                float              # The running time in seconds
            ]
        """
        start_time = time.time()  # Record the start time
        sandbox = sand_box.Sandbox()
        data = self._input.data

        new_code = response_to_code(sample, self._template, self._function_to_evolve)
        print(new_code)
        routes = sandbox.run(
            program=new_code,
            function_to_run=self._function_to_run,
            input=data,
            timeout_seconds=self._timeout_seconds
        )
        print(routes)
        total_distance = 0.0
        distance_matrix = data['distance_matrix']
        depot = data['depot']
        demand = data['demand']
        capacity = data['vehicle_capacity']
        all_nodes = set(range(len(demand)))
        all_nodes.remove(depot)
        visited_nodes = set()

        try:
            for i, route in enumerate(routes):
                if len(route) < 2 or route[0] != depot or route[-1] != depot:
                    raise ValueError(f"Invalid route {i}: {route} - must start and end at depot")

                route_distance = 0.0
                route_demand = 0
                for j in range(len(route) - 1):
                    from_node = route[j]
                    to_node = route[j + 1]
                    route_distance += distance_matrix[from_node][to_node]
                    if to_node != depot:
                        route_demand += demand[to_node]
                        visited_nodes.add(to_node)
                if route_demand > capacity:
                    raise ValueError(f"Route {i} overloaded: {route_demand}/{capacity}")
                total_distance += route_distance
                print(f"Vehicle {i} route: {route}")

            if visited_nodes != all_nodes:
                missing_nodes = all_nodes - visited_nodes
                raise ValueError(f"Not all nodes are visited. Missing nodes: {missing_nodes}")

            end_time = time.time()
            run_time = end_time - start_time
            print(f"Total Distance: {total_distance:.2f}")
            print(f"Vehicles used: {sum(1 for r in routes if len(r) > 2)}/{len(routes)}")
            print(f"Run time: {run_time:.4f} seconds")
            return True, total_distance, routes, run_time

        except ValueError as e:
            end_time = time.time()
            run_time = end_time - start_time
            print(f"Evaluation failed: {e}")
            print(f"Run time: {run_time:.4f} seconds")
            return False, "", [], run_time