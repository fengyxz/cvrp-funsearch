import multiprocessing
import logging

# Define the Sandbox class for securely executing code generated by the LLM
class Sandbox():
    """
    The Sandbox is used to securely execute code generated by the LLM and return the calculation results.

    Main functions:
    1) Prevent the code from performing malicious operations (e.g., accessing the Internet, consuming excessive RAM).
    2) Set a timeout to prevent infinite loops or endless execution.
    3) Ensure that CVRP constraints are strictly enforced, and illegal solutions are rejected.
    """

    def __init__(self, verbose=True):
        """
        Initialize the Sandbox.

        :param verbose: Whether to print detailed evaluation information, default is False.
        """
        self._verbose = verbose

    def run(
            self,
            program: str,
            function_to_run: str,  # Name of the function to be run
            input: any,  # Input dataset
            timeout_seconds: int,  # Maximum allowed execution time (execution fails if timeout is reached)
            **kwargs  # Additional parameters
    ) -> tuple[bool, float, any]:
        """
        Run `function_to_run(test_input)` and return the result.
        If the code execution fails (e.g., due to timeout, error, or violation of CVRP constraints), return (None, False).

        :param program: Python code to be executed (generated by the LLM).
        :param function_to_run: Name of the function to be executed in the code, e.g., 'evaluate'.
        :param test_input: Key of the current test input (used to retrieve data from the dataset).
        :param timeout_seconds: Maximum allowed execution time in seconds.
        :return: (score, success). If the execution is successful, return the calculated score and True; otherwise, return (None, False).
        """

        dataset = input  # Extract the current test data
        try:
            result_queue = multiprocessing.Queue()  # Queue for storing execution results
            process = multiprocessing.Process(
                target=self._compile_and_run_function,
                args=(program, function_to_run, dataset, result_queue)
            )

            process.start()  # Start the process
            process.join(timeout=timeout_seconds)  # Wait for the process to finish; terminate if timeout is reached

            if process.is_alive():
                # If timeout occurs, terminate the process and return an illegal solution
                process.terminate()
                process.join()
                return None
            if not result_queue.empty():
                results = result_queue.get_nowait()  # Get the calculation results
                return results
            return None
        except Exception:
            logging.error("Code execution error!", Exception.with_traceback)
            return None  # Code execution error

    def _compile_and_run_function(self, program, function_to_run, dataset, result_queue):
        """
        Compile and run the code generated by the LLM.
        Run the `function_to_run` generated by the LLM and return the calculation results.

        :param program: Python code to be executed (generated by the LLM).
        :param function_to_run: Name of the function to be executed in the code.
        :param dataset: Current test dataset.
        :param result_queue: Queue for storing execution results (to avoid data sharing issues between processes).
        """
        try:
            all_globals_namespace = {}  # Namespace for storing global variables, functions, and classes
            exec(program, all_globals_namespace)  # Execute the code generated by the LLM
            function_to_run = all_globals_namespace[function_to_run]  # Get the pointer to the target function
            # CVRP constraint check
            results = function_to_run(dataset)  # Run the path planning algorithm and return the solution
            result_queue.put(results)  # Return the evaluation value
        except Exception:
            result_queue.put(('FAIL', "", []))  # Code execution failed, return an illegal solution